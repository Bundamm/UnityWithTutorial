using UnityEngine;using UnityEngine.Events;public class PlayerController : MonoBehaviour{    [SerializeField] private float m_JumpForce;    [Range(0,.3f)][SerializeField] private float m_MovementSmoothing = .05f;        [SerializeField] private bool m_AirControl = false;    [SerializeField] private LayerMask m_WhatIsGround;    [SerializeField] private LayerMask m_WhatIsWall;    [SerializeField] private Transform m_GroundCheck;    [SerializeField] private Transform m_CeilingCheck;    [SerializeField] private Transform m_WallCheck;    public Animator animator;        const float k_GroundedRadius = .2f;    private bool m_Grounded;    const float k_WallRadius = .2f;    private Rigidbody2D m_Rigidbody2D;    private bool m_FacingRight = true;    private Vector3 m_Velocity = Vector3.zero;    private bool isWallSliding;    private float wallSlidingSpeed = 2f;    private bool isWallJumping;    private float wallJumpingDirection;    private float wallJumpingTime = 0.2f;    private float wallJumpingCounter;    private float wallJumpingDuration = 0.4f;    private Vector2 wallJumpingPower = new Vector2(8f, 16f);                [Header("Events")]    [Space]        public UnityEvent OnLandEvent;            [System.Serializable]    public class BoolEvent : UnityEvent<bool> { }        private void Awake()    {        m_Rigidbody2D = GetComponent<Rigidbody2D>();        if(OnLandEvent == null)            OnLandEvent = new UnityEvent();    }    private void FixedUpdate()    {        bool wasGrounded = m_Grounded;        m_Grounded = false;                Collider2D[] colliders = Physics2D.OverlapCircleAll(m_GroundCheck.position, k_GroundedRadius, m_WhatIsGround);        for (int i = 0; i < colliders.Length; i++)        {            if (colliders[i].gameObject != gameObject)            {                m_Grounded = true;                if (!wasGrounded)                    OnLandEvent.Invoke();            }        }    }    private bool isWalled()    {        return Physics2D.OverlapCircle(m_WallCheck.position, k_WallRadius, m_WhatIsWall);    }    public void WallSlide()    {        if (isWalled() && !m_Grounded && m_Rigidbody2D.linearVelocity.y != 0f)        {            isWallSliding = true;            m_Rigidbody2D.linearVelocity = new Vector2(m_Rigidbody2D.linearVelocity.x, Mathf.Clamp(m_Rigidbody2D.linearVelocity.y, -wallSlidingSpeed, float.MaxValue));            animator.SetBool("OnWall", true);            animator.SetBool("IsJumping", false);        }        else        {            isWallSliding = false;            animator.SetBool("OnWall", false);        }    }    public void Move(float move, bool jump)    {        if (m_Grounded || m_AirControl)        {            Vector3 targetVelocity = new Vector2(move * 10f, m_Rigidbody2D.linearVelocity.y);                        m_Rigidbody2D.linearVelocity = Vector3.SmoothDamp(m_Rigidbody2D.linearVelocity, targetVelocity, ref m_Velocity, m_MovementSmoothing);            if (move > 0 && !m_FacingRight)            {                Flip();            }            else if (move < 0 && m_FacingRight)            {                Flip();            }        }        if (m_Grounded && jump)        {            m_Grounded = false;            m_Rigidbody2D.AddForce(new Vector2(0f, m_JumpForce));        }    }    public void WallJump()    {        if (isWallSliding)        {            isWallJumping = false;            wallJumpingDirection = -transform.localScale.x;             wallJumpingCounter = wallJumpingTime;                        CancelInvoke(nameof(StopWallJumping));        }        else        {            wallJumpingCounter -= Time.deltaTime;        }        if (Input.GetButtonDown("Jump") && wallJumpingCounter > 0f)        {            isWallJumping = true;            m_Rigidbody2D.linearVelocity = new Vector2(wallJumpingDirection * wallJumpingPower.x, wallJumpingPower.y);            wallJumpingCounter = 0f;            if (transform.localScale.x != wallJumpingDirection)            {                Flip();            }            Invoke(nameof(StopWallJumping), wallJumpingDuration);            animator.SetBool("IsJumping", true);        }    }    private void StopWallJumping()    {        isWallJumping = false;    }    private void Flip()    {        m_FacingRight = !m_FacingRight;                Vector3 theScale = transform.localScale;        theScale.x *= -1;        transform.localScale = theScale;    }    }